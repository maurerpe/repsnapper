/*
    This file is a part of the RepSnapper project.
    Copyright (C) 2010  Kulitorum

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/
#include "triangle.h"
#include "geometry.h"

#define MAX(a,b) ((a) > (b) ? (a) : (b))
#define MIN(a,b) ((a) < (b) ? (a) : (b))

Triangle::Triangle(const Vector3d &Point1,
		   const Vector3d &Point2, const Vector3d &Point3) {
  A = Point1;
  B = Point2;
  C = Point3;
  
  calcNormal();
}

void Triangle::calcNormal() {
  Vector3d AA = C - A;
  Vector3d BB = C - B;
  
  Normal = normalized(AA.cross(BB));
}

Triangle Triangle::transformed(const Matrix4d &T) const {
  return Triangle(T*A, T*B, T*C);
}


void Triangle::invertNormal() {
  Vector3d swap = A;
  A = C;
  C = swap;
  
  calcNormal();
}

void Triangle::mirrorX(const Vector3d &center) {
  for (uint i = 0; i < 3; i++)
    operator[](i).x() = center.x()-operator[](i).x();
  
  invertNormal();
}

Vector3d &Triangle::operator[] (const uint index) {
  switch(index) {
  case 0: return A;
  case 1: return B;
  case 2: return C;
  }
  
  return A;
}

Vector3d const &Triangle::operator[] (const uint index) const {
  switch(index) {
  case 0: return A;
  case 1: return B;
  case 2: return C;
  }
  
  return A;
}

bool Triangle::isConnectedTo(Triangle const &other, double maxsqerr) const {
  // first test equal, faster
  for (uint j = 0; j < 3; j++)  {
    if (( A == other[j]))  return true;
    if (( B == other[j]))  return true;
    if (( C == other[j]))  return true;
  }
  
  if (maxsqerr>0) {
    // if not, test distance
    for (uint j = 0; j < 3; j++)  {
      if ( A.squared_distance(other[j]) < maxsqerr)  return true;
      if ( B.squared_distance(other[j]) < maxsqerr)  return true;
      if ( C.squared_distance(other[j]) < maxsqerr)  return true;
    }
  }
  
  return false;
}

double Triangle::area() const {
  return 0.5* ((C-A).cross(B-A)).length() ;
}

// add all these to get shape volume
double Triangle::projectedvolume(const Matrix4d &T) const {
  if (Normal.z()==0) return 0;
  Triangle xyproj = Triangle(Vector3d(A.x(),A.y(),0),
			     Vector3d(B.x(),B.y(),0),
			     Vector3d(C.x(),C.y(),0));
  Vector3d min = GetMin(T);
  Vector3d max = GetMax(T);
  double vol =  xyproj.area()*0.5*(max.z()+min.z());
  if (Normal.z()<0) vol=-vol;
  return vol;
}

Vector3d Triangle::GetMax(const Matrix4d &T) const {
  Vector3d max(-99999999.0, -99999999.0, -99999999.0);
  Vector3d TA=T*A, TB=T*B, TC=T*C;
  
  for (uint i = 0; i < 3; i++) {
    max[i] = MAX(max[i], TA[i]);
    max[i] = MAX(max[i], TB[i]);
    max[i] = MAX(max[i], TC[i]);
  }
  
  return max;
}

Vector3d Triangle::GetMin(const Matrix4d &T) const {
  Vector3d min(99999999.0, 99999999.0, 99999999.0);
  Vector3d TA=T*A,TB=T*B,TC=T*C;
  for (uint i = 0; i < 3; i++) {
    min[i] = MIN(min[i], TA[i]);
    min[i] = MIN(min[i], TB[i]);
    min[i] = MIN(min[i], TC[i]);
  }
  
  return min;
}

void Triangle::AccumulateMinMax(Vector3d &min, Vector3d &max, const Matrix4d &T) {
  Vector3d tmin = GetMin(T);
  Vector3d tmax = GetMax(T);
  
  for (uint i = 0; i < 3; i++) {
    min[i] = MIN(tmin[i], min[i]);
    max[i] = MAX(tmax[i], max[i]);
  }
}

void Triangle::shift1(void) {
  Vector3d shift = A;
  A = B;
  B = C;
  C = shift;
}

void Triangle::shift2(void) {
  Vector3d shift = A;
  A = C;
  C = B;
  B = shift;
}

void Triangle::divide(vector<Triangle> &above, vector<Triangle> &below,
		      Vector2d &start, Vector2d &stop) {
  start = Vector2d(0, 0);
  stop  = Vector2d(0, 0);

  // Most common cases: all above or all below
  if (A.z() > 0 && B.z() > 0 && C.z() > 0) {
    above.push_back(*this);
    return;
  }

  if (A.z() < 0 && B.z() < 0 && C.z() < 0) {
    below.push_back(*this);
    return;
  }
  
  // Handle if one or more vertex is at z = 0
  if (A.z() == 0) {
    if (B.z() > 0 && C.z() > 0) {
      above.push_back(*this);
      return;
    }

    if (B.z() < 0 && C.z() < 0) {
      below.push_back(*this);
      return;
    }
    
    if (B.z() == 0) {
      if (C.z() == 0)
	// Do nothing, all three are at z = 0, will be generated by line2poly
	return;

      start.x() = A.x();
      start.y() = A.y();
      stop.x()  = B.x();
      stop.y()  = B.y();
      
      if (C.z() > 0) {
	above.push_back(*this);
	return;
      }
 
      below.push_back(*this);
      return;
    }
    
    if (C.z() == 0) {
      start.x() = A.x();
      start.y() = A.y();
      stop.x()  = C.x();
      stop.y()  = C.y();
      
      if (B.z() > 0) {
	above.push_back(*this);
	return;
      }
      below.push_back(*this);
      return;
    }
    
    double ratio = B.z() / (B.z() - C.z());
    double bcx = ratio * (C.x() - B.x()) + B.x();
    double bcy = ratio * (C.y() - B.y()) + B.y();
    start.x() = A.x();
    start.y() = B.y();
    stop.x() = bcx;
    stop.y() = bcy;

    Vector3d D(bcx, bcy, 0);
    
    Triangle abd(A, B, D);
    Triangle adc(A, D, C);
    
    if (B.z() > 0) {
      above.push_back(abd);
      below.push_back(adc);
    } else {
      above.push_back(adc);
      below.push_back(abd);
    }
    return;
  }
  
  if (B.z() == 0) {
    shift1();
    
    divide(above, below, start, stop);
    return;
  }
  
  if (C.z() == 0) {
    shift2();
    
    divide(above, below, start, stop);
    return;
  }

  // Two points on one side, one on the other
  if (B.z() * C.z() > 0) {
    // A is the lone point
    double bratio = A.z() / (A.z() - B.z());
    double abx = bratio * (B.x() - A.x()) + A.x();
    double aby = bratio * (B.y() - A.y()) + A.y();
    
    double cratio = A.z() / (A.z() - C.z());
    double acx = cratio * (C.x() - A.x()) + A.x();
    double acy = cratio * (C.y() - A.y()) + A.y();

    start.x() = abx;
    start.y() = aby;
    stop.x()  = acx;
    stop.y()  = acy;

    Vector3d D(abx, aby, 0);
    Vector3d E(acx, acy, 0);
    
    Triangle ade(A, D, E);
    Triangle dbc(D, B, C);
    Triangle edc(E, D, C);

    if (A.z() > 0) {
      above.push_back(ade);
      below.push_back(dbc);
      below.push_back(edc);
    } else {
      below.push_back(ade);
      above.push_back(dbc);
      above.push_back(edc);
    }

    return;
  }

  if (A.z() * C.z() > 0) {
    // B is the lone point
    shift1();

    divide(above, below, start, stop);
    return;
  }
  
  // C is the lone point
  shift2();
  
  divide(above, below, start, stop);
}

string Triangle::getSTLfacet(const Matrix4d &T) const {
  Vector3d TA=T*A,TB=T*B,TC=T*C,TN=T*Normal;TN.normalize();
  stringstream sstr;
  sstr << "  facet normal " << TN.x() << " " << TN.x() << " " << TN.z() <<endl;
  sstr << "    outer loop"  << endl;
  sstr << "      vertex "<< scientific << TA.x() << " " << TA.y() << " " << TA.z() <<endl;
  sstr << "      vertex "<< scientific << TB.x() << " " << TB.y() << " " << TB.z() <<endl;
  sstr << "      vertex "<< scientific << TC.x() << " " << TC.y() << " " << TC.z() <<endl;
  sstr << "    endloop" << endl;
  sstr << "  endfacet" << endl;
  return sstr.str();
}

string Triangle::info() const {
  ostringstream ostr;
  ostr <<"Triangle A="<< A
       <<", B="<< B
       <<", C="<< C
       <<", N="<< Normal ;
  return ostr.str();
}
